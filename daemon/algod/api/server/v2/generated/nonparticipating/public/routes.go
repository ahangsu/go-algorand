// Package public provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package public

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	. "github.com/algorand/go-algorand/daemon/algod/api/server/v2/generated/model"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	GetApplicationBoxByName(ctx echo.Context, applicationId uint64, params GetApplicationBoxByNameParams) error
	// Get all box names for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	GetApplicationBoxes(ctx echo.Context, applicationId uint64, params GetApplicationBoxesParams) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get the block hash for the block on the given round.
	// (GET /v2/blocks/{round}/hash)
	GetBlockHash(ctx echo.Context, round uint64) error
	// Gets a proof for a given light block header inside a state proof commitment
	// (GET /v2/blocks/{round}/lightheader/proof)
	GetLightBlockHeaderProof(ctx echo.Context, round uint64) error
	// Get a proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetTransactionProof(ctx echo.Context, round uint64, txid string, params GetTransactionProofParams) error
	// Get a LedgerStateDelta object for a given transaction group
	// (GET /v2/deltas/txn/group/{id})
	GetLedgerStateDeltaForTransactionGroup(ctx echo.Context, id string, params GetLedgerStateDeltaForTransactionGroupParams) error
	// Get a LedgerStateDelta object for a given round
	// (GET /v2/deltas/{round})
	GetLedgerStateDelta(ctx echo.Context, round uint64, params GetLedgerStateDeltaParams) error
	// Get LedgerStateDelta objects for all transaction groups in a given round
	// (GET /v2/deltas/{round}/txn/group)
	GetTransactionGroupLedgerStateDeltasForRound(ctx echo.Context, round uint64, params GetTransactionGroupLedgerStateDeltasForRoundParams) error
	// Returns the timestamp offset. Timestamp offsets can only be set in dev mode.
	// (GET /v2/devmode/blocks/offset)
	GetBlockTimeStampOffset(ctx echo.Context) error
	// Given a timestamp offset in seconds, adds the offset to every subsequent block header's timestamp.
	// (POST /v2/devmode/blocks/offset/{offset})
	SetBlockTimeStampOffset(ctx echo.Context, offset uint64) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Get a state proof that covers a given round
	// (GET /v2/stateproofs/{round})
	GetStateProof(ctx echo.Context, round uint64) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for a round after the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context, params TealCompileParams) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Simulates a raw transaction or transaction group as it would be evaluated on the network. The simulation will use blockchain state from the latest committed round.
	// (POST /v2/transactions/simulate)
	SimulateTransaction(ctx echo.Context, params SimulateTransactionParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetApplicationBoxByName converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxByName(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxByNameParams
	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxByName(ctx, applicationId, params)
	return err
}

// GetApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxes(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxesParams
	// ------------- Optional query parameter "max" -------------

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxes(ctx, applicationId, params)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetBlockHash converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockHash(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockHash(ctx, round)
	return err
}

// GetLightBlockHeaderProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetLightBlockHeaderProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLightBlockHeaderProof(ctx, round)
	return err
}

// GetTransactionProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameterWithLocation("simple", false, "txid", runtime.ParamLocationPath, ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionProofParams
	// ------------- Optional query parameter "hashtype" -------------

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTransactionProof(ctx, round, txid, params)
	return err
}

// GetLedgerStateDeltaForTransactionGroup converts echo context to params.
func (w *ServerInterfaceWrapper) GetLedgerStateDeltaForTransactionGroup(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLedgerStateDeltaForTransactionGroupParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLedgerStateDeltaForTransactionGroup(ctx, id, params)
	return err
}

// GetLedgerStateDelta converts echo context to params.
func (w *ServerInterfaceWrapper) GetLedgerStateDelta(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLedgerStateDeltaParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLedgerStateDelta(ctx, round, params)
	return err
}

// GetTransactionGroupLedgerStateDeltasForRound converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionGroupLedgerStateDeltasForRound(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionGroupLedgerStateDeltasForRoundParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTransactionGroupLedgerStateDeltasForRound(ctx, round, params)
	return err
}

// GetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockTimeStampOffset(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockTimeStampOffset(ctx)
	return err
}

// SetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) SetBlockTimeStampOffset(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "offset" -------------
	var offset uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "offset", runtime.ParamLocationPath, ctx.Param("offset"), &offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SetBlockTimeStampOffset(ctx, offset)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStateProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetStateProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStateProof(ctx, round)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params TealCompileParams
	// ------------- Optional query parameter "sourcemap" -------------

	err = runtime.BindQueryParameter("form", true, false, "sourcemap", ctx.QueryParams(), &params.Sourcemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sourcemap: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx, params)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// SimulateTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) SimulateTransaction(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params SimulateTransactionParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SimulateTransaction(ctx, params)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface, m ...echo.MiddlewareFunc) {
	RegisterHandlersWithBaseURL(router, si, "", m...)
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET(baseURL+"/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET(baseURL+"/v2/applications/:application-id/box", wrapper.GetApplicationBoxByName, m...)
	router.GET(baseURL+"/v2/applications/:application-id/boxes", wrapper.GetApplicationBoxes, m...)
	router.GET(baseURL+"/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET(baseURL+"/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET(baseURL+"/v2/blocks/:round/hash", wrapper.GetBlockHash, m...)
	router.GET(baseURL+"/v2/blocks/:round/lightheader/proof", wrapper.GetLightBlockHeaderProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/transactions/:txid/proof", wrapper.GetTransactionProof, m...)
	router.GET(baseURL+"/v2/deltas/txn/group/:id", wrapper.GetLedgerStateDeltaForTransactionGroup, m...)
	router.GET(baseURL+"/v2/deltas/:round", wrapper.GetLedgerStateDelta, m...)
	router.GET(baseURL+"/v2/deltas/:round/txn/group", wrapper.GetTransactionGroupLedgerStateDeltasForRound, m...)
	router.GET(baseURL+"/v2/devmode/blocks/offset", wrapper.GetBlockTimeStampOffset, m...)
	router.POST(baseURL+"/v2/devmode/blocks/offset/:offset", wrapper.SetBlockTimeStampOffset, m...)
	router.GET(baseURL+"/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET(baseURL+"/v2/stateproofs/:round", wrapper.GetStateProof, m...)
	router.GET(baseURL+"/v2/status", wrapper.GetStatus, m...)
	router.GET(baseURL+"/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST(baseURL+"/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST(baseURL+"/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST(baseURL+"/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.GET(baseURL+"/v2/transactions/params", wrapper.TransactionParams, m...)
	router.POST(baseURL+"/v2/transactions/simulate", wrapper.SimulateTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"/z8AAP//dBrK6TB/AQA=",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
