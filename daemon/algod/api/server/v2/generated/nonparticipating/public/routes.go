// Package public provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package public

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	. "github.com/algorand/go-algorand/daemon/algod/api/server/v2/generated/model"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	GetApplicationBoxByName(ctx echo.Context, applicationId uint64, params GetApplicationBoxByNameParams) error
	// Get all box names for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	GetApplicationBoxes(ctx echo.Context, applicationId uint64, params GetApplicationBoxesParams) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get the block hash for the block on the given round.
	// (GET /v2/blocks/{round}/hash)
	GetBlockHash(ctx echo.Context, round uint64) error
	// Gets a proof for a given light block header inside a state proof commitment
	// (GET /v2/blocks/{round}/lightheader/proof)
	GetLightBlockHeaderProof(ctx echo.Context, round uint64) error
	// Get a proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetTransactionProof(ctx echo.Context, round uint64, txid string, params GetTransactionProofParams) error
	// Get a LedgerStateDelta object for a given transaction group
	// (GET /v2/deltas/txn/group/{id})
	GetLedgerStateDeltaForTransactionGroup(ctx echo.Context, id string, params GetLedgerStateDeltaForTransactionGroupParams) error
	// Get a LedgerStateDelta object for a given round
	// (GET /v2/deltas/{round})
	GetLedgerStateDelta(ctx echo.Context, round uint64, params GetLedgerStateDeltaParams) error
	// Get LedgerStateDelta objects for all transaction groups in a given round
	// (GET /v2/deltas/{round}/txn/group)
	GetTransactionGroupLedgerStateDeltasForRound(ctx echo.Context, round uint64, params GetTransactionGroupLedgerStateDeltasForRoundParams) error
	// Returns the timestamp offset. Timestamp offsets can only be set in dev mode.
	// (GET /v2/devmode/blocks/offset)
	GetBlockTimeStampOffset(ctx echo.Context) error
	// Given a timestamp offset in seconds, adds the offset to every subsequent block header's timestamp.
	// (POST /v2/devmode/blocks/offset/{offset})
	SetBlockTimeStampOffset(ctx echo.Context, offset uint64) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Get a state proof that covers a given round
	// (GET /v2/stateproofs/{round})
	GetStateProof(ctx echo.Context, round uint64) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for a round after the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context, params TealCompileParams) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Simulates a raw transaction or transaction group as it would be evaluated on the network. The simulation will use blockchain state from the latest committed round.
	// (POST /v2/transactions/simulate)
	SimulateTransaction(ctx echo.Context, params SimulateTransactionParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetApplicationBoxByName converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxByName(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxByNameParams
	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxByName(ctx, applicationId, params)
	return err
}

// GetApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxes(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxesParams
	// ------------- Optional query parameter "max" -------------

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxes(ctx, applicationId, params)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetBlockHash converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockHash(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockHash(ctx, round)
	return err
}

// GetLightBlockHeaderProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetLightBlockHeaderProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLightBlockHeaderProof(ctx, round)
	return err
}

// GetTransactionProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameterWithLocation("simple", false, "txid", runtime.ParamLocationPath, ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionProofParams
	// ------------- Optional query parameter "hashtype" -------------

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTransactionProof(ctx, round, txid, params)
	return err
}

// GetLedgerStateDeltaForTransactionGroup converts echo context to params.
func (w *ServerInterfaceWrapper) GetLedgerStateDeltaForTransactionGroup(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLedgerStateDeltaForTransactionGroupParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLedgerStateDeltaForTransactionGroup(ctx, id, params)
	return err
}

// GetLedgerStateDelta converts echo context to params.
func (w *ServerInterfaceWrapper) GetLedgerStateDelta(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLedgerStateDeltaParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLedgerStateDelta(ctx, round, params)
	return err
}

// GetTransactionGroupLedgerStateDeltasForRound converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionGroupLedgerStateDeltasForRound(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionGroupLedgerStateDeltasForRoundParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTransactionGroupLedgerStateDeltasForRound(ctx, round, params)
	return err
}

// GetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockTimeStampOffset(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockTimeStampOffset(ctx)
	return err
}

// SetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) SetBlockTimeStampOffset(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "offset" -------------
	var offset uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "offset", runtime.ParamLocationPath, ctx.Param("offset"), &offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SetBlockTimeStampOffset(ctx, offset)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStateProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetStateProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStateProof(ctx, round)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params TealCompileParams
	// ------------- Optional query parameter "sourcemap" -------------

	err = runtime.BindQueryParameter("form", true, false, "sourcemap", ctx.QueryParams(), &params.Sourcemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sourcemap: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx, params)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// SimulateTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) SimulateTransaction(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params SimulateTransactionParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SimulateTransaction(ctx, params)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface, m ...echo.MiddlewareFunc) {
	RegisterHandlersWithBaseURL(router, si, "", m...)
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET(baseURL+"/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET(baseURL+"/v2/applications/:application-id/box", wrapper.GetApplicationBoxByName, m...)
	router.GET(baseURL+"/v2/applications/:application-id/boxes", wrapper.GetApplicationBoxes, m...)
	router.GET(baseURL+"/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET(baseURL+"/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET(baseURL+"/v2/blocks/:round/hash", wrapper.GetBlockHash, m...)
	router.GET(baseURL+"/v2/blocks/:round/lightheader/proof", wrapper.GetLightBlockHeaderProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/transactions/:txid/proof", wrapper.GetTransactionProof, m...)
	router.GET(baseURL+"/v2/deltas/txn/group/:id", wrapper.GetLedgerStateDeltaForTransactionGroup, m...)
	router.GET(baseURL+"/v2/deltas/:round", wrapper.GetLedgerStateDelta, m...)
	router.GET(baseURL+"/v2/deltas/:round/txn/group", wrapper.GetTransactionGroupLedgerStateDeltasForRound, m...)
	router.GET(baseURL+"/v2/devmode/blocks/offset", wrapper.GetBlockTimeStampOffset, m...)
	router.POST(baseURL+"/v2/devmode/blocks/offset/:offset", wrapper.SetBlockTimeStampOffset, m...)
	router.GET(baseURL+"/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET(baseURL+"/v2/stateproofs/:round", wrapper.GetStateProof, m...)
	router.GET(baseURL+"/v2/status", wrapper.GetStatus, m...)
	router.GET(baseURL+"/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST(baseURL+"/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST(baseURL+"/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST(baseURL+"/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.GET(baseURL+"/v2/transactions/params", wrapper.TransactionParams, m...)
	router.POST(baseURL+"/v2/transactions/simulate", wrapper.SimulateTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"rYxG8+nDp/8fAAD//yvFDUrxfwEA",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
