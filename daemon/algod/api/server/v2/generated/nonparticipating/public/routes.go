// Package public provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package public

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	. "github.com/algorand/go-algorand/daemon/algod/api/server/v2/generated/model"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	GetApplicationBoxByName(ctx echo.Context, applicationId uint64, params GetApplicationBoxByNameParams) error
	// Get all box names for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	GetApplicationBoxes(ctx echo.Context, applicationId uint64, params GetApplicationBoxesParams) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get the block hash for the block on the given round.
	// (GET /v2/blocks/{round}/hash)
	GetBlockHash(ctx echo.Context, round uint64) error
	// Gets a proof for a given light block header inside a state proof commitment
	// (GET /v2/blocks/{round}/lightheader/proof)
	GetLightBlockHeaderProof(ctx echo.Context, round uint64) error
	// Get a proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetTransactionProof(ctx echo.Context, round uint64, txid string, params GetTransactionProofParams) error
	// Get a LedgerStateDelta object for a given transaction group
	// (GET /v2/deltas/txn/group/{id})
	GetLedgerStateDeltaForTransactionGroup(ctx echo.Context, id string, params GetLedgerStateDeltaForTransactionGroupParams) error
	// Get a LedgerStateDelta object for a given round
	// (GET /v2/deltas/{round})
	GetLedgerStateDelta(ctx echo.Context, round uint64, params GetLedgerStateDeltaParams) error
	// Get LedgerStateDelta objects for all transaction groups in a given round
	// (GET /v2/deltas/{round}/txn/group)
	GetTransactionGroupLedgerStateDeltasForRound(ctx echo.Context, round uint64, params GetTransactionGroupLedgerStateDeltasForRoundParams) error
	// Returns the timestamp offset. Timestamp offsets can only be set in dev mode.
	// (GET /v2/devmode/blocks/offset)
	GetBlockTimeStampOffset(ctx echo.Context) error
	// Given a timestamp offset in seconds, adds the offset to every subsequent block header's timestamp.
	// (POST /v2/devmode/blocks/offset/{offset})
	SetBlockTimeStampOffset(ctx echo.Context, offset uint64) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Get a state proof that covers a given round
	// (GET /v2/stateproofs/{round})
	GetStateProof(ctx echo.Context, round uint64) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for a round after the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context, params TealCompileParams) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Simulates a raw transaction or transaction group as it would be evaluated on the network. The simulation will use blockchain state from the latest committed round.
	// (POST /v2/transactions/simulate)
	SimulateTransaction(ctx echo.Context, params SimulateTransactionParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetApplicationBoxByName converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxByName(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxByNameParams
	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxByName(ctx, applicationId, params)
	return err
}

// GetApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxes(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxesParams
	// ------------- Optional query parameter "max" -------------

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxes(ctx, applicationId, params)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetBlockHash converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockHash(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockHash(ctx, round)
	return err
}

// GetLightBlockHeaderProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetLightBlockHeaderProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLightBlockHeaderProof(ctx, round)
	return err
}

// GetTransactionProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameterWithLocation("simple", false, "txid", runtime.ParamLocationPath, ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionProofParams
	// ------------- Optional query parameter "hashtype" -------------

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTransactionProof(ctx, round, txid, params)
	return err
}

// GetLedgerStateDeltaForTransactionGroup converts echo context to params.
func (w *ServerInterfaceWrapper) GetLedgerStateDeltaForTransactionGroup(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLedgerStateDeltaForTransactionGroupParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLedgerStateDeltaForTransactionGroup(ctx, id, params)
	return err
}

// GetLedgerStateDelta converts echo context to params.
func (w *ServerInterfaceWrapper) GetLedgerStateDelta(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLedgerStateDeltaParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLedgerStateDelta(ctx, round, params)
	return err
}

// GetTransactionGroupLedgerStateDeltasForRound converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionGroupLedgerStateDeltasForRound(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionGroupLedgerStateDeltasForRoundParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTransactionGroupLedgerStateDeltasForRound(ctx, round, params)
	return err
}

// GetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockTimeStampOffset(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockTimeStampOffset(ctx)
	return err
}

// SetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) SetBlockTimeStampOffset(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "offset" -------------
	var offset uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "offset", runtime.ParamLocationPath, ctx.Param("offset"), &offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SetBlockTimeStampOffset(ctx, offset)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStateProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetStateProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStateProof(ctx, round)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params TealCompileParams
	// ------------- Optional query parameter "sourcemap" -------------

	err = runtime.BindQueryParameter("form", true, false, "sourcemap", ctx.QueryParams(), &params.Sourcemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sourcemap: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx, params)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// SimulateTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) SimulateTransaction(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params SimulateTransactionParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SimulateTransaction(ctx, params)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface, m ...echo.MiddlewareFunc) {
	RegisterHandlersWithBaseURL(router, si, "", m...)
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET(baseURL+"/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET(baseURL+"/v2/applications/:application-id/box", wrapper.GetApplicationBoxByName, m...)
	router.GET(baseURL+"/v2/applications/:application-id/boxes", wrapper.GetApplicationBoxes, m...)
	router.GET(baseURL+"/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET(baseURL+"/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET(baseURL+"/v2/blocks/:round/hash", wrapper.GetBlockHash, m...)
	router.GET(baseURL+"/v2/blocks/:round/lightheader/proof", wrapper.GetLightBlockHeaderProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/transactions/:txid/proof", wrapper.GetTransactionProof, m...)
	router.GET(baseURL+"/v2/deltas/txn/group/:id", wrapper.GetLedgerStateDeltaForTransactionGroup, m...)
	router.GET(baseURL+"/v2/deltas/:round", wrapper.GetLedgerStateDelta, m...)
	router.GET(baseURL+"/v2/deltas/:round/txn/group", wrapper.GetTransactionGroupLedgerStateDeltasForRound, m...)
	router.GET(baseURL+"/v2/devmode/blocks/offset", wrapper.GetBlockTimeStampOffset, m...)
	router.POST(baseURL+"/v2/devmode/blocks/offset/:offset", wrapper.SetBlockTimeStampOffset, m...)
	router.GET(baseURL+"/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET(baseURL+"/v2/stateproofs/:round", wrapper.GetStateProof, m...)
	router.GET(baseURL+"/v2/status", wrapper.GetStatus, m...)
	router.GET(baseURL+"/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST(baseURL+"/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST(baseURL+"/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST(baseURL+"/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.GET(baseURL+"/v2/transactions/params", wrapper.TransactionParams, m...)
	router.POST(baseURL+"/v2/transactions/simulate", wrapper.SimulateTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"/o9e+i8kWxmN5tOHT/9/AAAA///gy7vWIIEBAA==",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
