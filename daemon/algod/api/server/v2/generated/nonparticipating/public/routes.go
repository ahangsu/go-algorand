// Package public provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package public

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	. "github.com/algorand/go-algorand/daemon/algod/api/server/v2/generated/model"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	GetApplicationBoxByName(ctx echo.Context, applicationId uint64, params GetApplicationBoxByNameParams) error
	// Get all box names for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	GetApplicationBoxes(ctx echo.Context, applicationId uint64, params GetApplicationBoxesParams) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get the block hash for the block on the given round.
	// (GET /v2/blocks/{round}/hash)
	GetBlockHash(ctx echo.Context, round uint64) error
	// Gets a proof for a given light block header inside a state proof commitment
	// (GET /v2/blocks/{round}/lightheader/proof)
	GetLightBlockHeaderProof(ctx echo.Context, round uint64) error
	// Get a proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetTransactionProof(ctx echo.Context, round uint64, txid string, params GetTransactionProofParams) error
	// Returns the timestamp offset. Timestamp offsets can only be set in dev mode.
	// (GET /v2/devmode/blocks/offset)
	GetBlockTimeStampOffset(ctx echo.Context) error
	// Given a timestamp offset in seconds, adds the offset to every subsequent block header's timestamp.
	// (POST /v2/devmode/blocks/offset/{offset})
	SetBlockTimeStampOffset(ctx echo.Context, offset uint64) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Get a state proof that covers a given round
	// (GET /v2/stateproofs/{round})
	GetStateProof(ctx echo.Context, round uint64) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for a round after the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context, params TealCompileParams) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Simulates a raw transaction or transaction group as it would be evaluated on the network. The simulation will use blockchain state from the latest committed round.
	// (POST /v2/transactions/simulate)
	SimulateTransaction(ctx echo.Context, params SimulateTransactionParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetApplicationBoxByName converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxByName(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxByNameParams
	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxByName(ctx, applicationId, params)
	return err
}

// GetApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxes(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxesParams
	// ------------- Optional query parameter "max" -------------

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxes(ctx, applicationId, params)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetBlockHash converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockHash(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockHash(ctx, round)
	return err
}

// GetLightBlockHeaderProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetLightBlockHeaderProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLightBlockHeaderProof(ctx, round)
	return err
}

// GetTransactionProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameterWithLocation("simple", false, "txid", runtime.ParamLocationPath, ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionProofParams
	// ------------- Optional query parameter "hashtype" -------------

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTransactionProof(ctx, round, txid, params)
	return err
}

// GetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockTimeStampOffset(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockTimeStampOffset(ctx)
	return err
}

// SetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) SetBlockTimeStampOffset(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "offset" -------------
	var offset uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "offset", runtime.ParamLocationPath, ctx.Param("offset"), &offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SetBlockTimeStampOffset(ctx, offset)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStateProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetStateProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStateProof(ctx, round)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params TealCompileParams
	// ------------- Optional query parameter "sourcemap" -------------

	err = runtime.BindQueryParameter("form", true, false, "sourcemap", ctx.QueryParams(), &params.Sourcemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sourcemap: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx, params)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// SimulateTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) SimulateTransaction(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params SimulateTransactionParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SimulateTransaction(ctx, params)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface, m ...echo.MiddlewareFunc) {
	RegisterHandlersWithBaseURL(router, si, "", m...)
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET(baseURL+"/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET(baseURL+"/v2/applications/:application-id/box", wrapper.GetApplicationBoxByName, m...)
	router.GET(baseURL+"/v2/applications/:application-id/boxes", wrapper.GetApplicationBoxes, m...)
	router.GET(baseURL+"/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET(baseURL+"/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET(baseURL+"/v2/blocks/:round/hash", wrapper.GetBlockHash, m...)
	router.GET(baseURL+"/v2/blocks/:round/lightheader/proof", wrapper.GetLightBlockHeaderProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/transactions/:txid/proof", wrapper.GetTransactionProof, m...)
	router.GET(baseURL+"/v2/devmode/blocks/offset", wrapper.GetBlockTimeStampOffset, m...)
	router.POST(baseURL+"/v2/devmode/blocks/offset/:offset", wrapper.SetBlockTimeStampOffset, m...)
	router.GET(baseURL+"/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET(baseURL+"/v2/stateproofs/:round", wrapper.GetStateProof, m...)
	router.GET(baseURL+"/v2/status", wrapper.GetStatus, m...)
	router.GET(baseURL+"/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST(baseURL+"/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST(baseURL+"/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST(baseURL+"/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.GET(baseURL+"/v2/transactions/params", wrapper.TransactionParams, m...)
	router.POST(baseURL+"/v2/transactions/simulate", wrapper.SimulateTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"SbFmAQA=",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
