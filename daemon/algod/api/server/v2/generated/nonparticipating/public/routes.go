// Package public provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package public

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	. "github.com/algorand/go-algorand/daemon/algod/api/server/v2/generated/model"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	GetApplicationBoxByName(ctx echo.Context, applicationId uint64, params GetApplicationBoxByNameParams) error
	// Get all box names for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	GetApplicationBoxes(ctx echo.Context, applicationId uint64, params GetApplicationBoxesParams) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get the block hash for the block on the given round.
	// (GET /v2/blocks/{round}/hash)
	GetBlockHash(ctx echo.Context, round uint64) error
	// Gets a proof for a given light block header inside a state proof commitment
	// (GET /v2/blocks/{round}/lightheader/proof)
	GetLightBlockHeaderProof(ctx echo.Context, round uint64) error
	// Get a proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetTransactionProof(ctx echo.Context, round uint64, txid string, params GetTransactionProofParams) error
	// Returns the timestamp offset. Timestamp offsets can only be set in dev mode.
	// (GET /v2/devmode/blocks/offset)
	GetBlockTimeStampOffset(ctx echo.Context) error
	// Given a timestamp offset in seconds, adds the offset to every subsequent block header's timestamp.
	// (POST /v2/devmode/blocks/offset/{offset})
	SetBlockTimeStampOffset(ctx echo.Context, offset uint64) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Get a state proof that covers a given round
	// (GET /v2/stateproofs/{round})
	GetStateProof(ctx echo.Context, round uint64) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for a round after the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context, params TealCompileParams) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Simulates a raw transaction or transaction group as it would be evaluated on the network. The simulation will use blockchain state from the latest committed round.
	// (POST /v2/transactions/simulate)
	SimulateTransaction(ctx echo.Context, params SimulateTransactionParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetApplicationBoxByName converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxByName(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxByNameParams
	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxByName(ctx, applicationId, params)
	return err
}

// GetApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxes(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxesParams
	// ------------- Optional query parameter "max" -------------

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxes(ctx, applicationId, params)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetBlockHash converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockHash(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockHash(ctx, round)
	return err
}

// GetLightBlockHeaderProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetLightBlockHeaderProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLightBlockHeaderProof(ctx, round)
	return err
}

// GetTransactionProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameterWithLocation("simple", false, "txid", runtime.ParamLocationPath, ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionProofParams
	// ------------- Optional query parameter "hashtype" -------------

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTransactionProof(ctx, round, txid, params)
	return err
}

// GetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockTimeStampOffset(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockTimeStampOffset(ctx)
	return err
}

// SetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) SetBlockTimeStampOffset(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "offset" -------------
	var offset uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "offset", runtime.ParamLocationPath, ctx.Param("offset"), &offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SetBlockTimeStampOffset(ctx, offset)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStateProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetStateProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStateProof(ctx, round)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params TealCompileParams
	// ------------- Optional query parameter "sourcemap" -------------

	err = runtime.BindQueryParameter("form", true, false, "sourcemap", ctx.QueryParams(), &params.Sourcemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sourcemap: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx, params)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// SimulateTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) SimulateTransaction(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params SimulateTransactionParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SimulateTransaction(ctx, params)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface, m ...echo.MiddlewareFunc) {
	RegisterHandlersWithBaseURL(router, si, "", m...)
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET(baseURL+"/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET(baseURL+"/v2/applications/:application-id/box", wrapper.GetApplicationBoxByName, m...)
	router.GET(baseURL+"/v2/applications/:application-id/boxes", wrapper.GetApplicationBoxes, m...)
	router.GET(baseURL+"/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET(baseURL+"/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET(baseURL+"/v2/blocks/:round/hash", wrapper.GetBlockHash, m...)
	router.GET(baseURL+"/v2/blocks/:round/lightheader/proof", wrapper.GetLightBlockHeaderProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/transactions/:txid/proof", wrapper.GetTransactionProof, m...)
	router.GET(baseURL+"/v2/devmode/blocks/offset", wrapper.GetBlockTimeStampOffset, m...)
	router.POST(baseURL+"/v2/devmode/blocks/offset/:offset", wrapper.SetBlockTimeStampOffset, m...)
	router.GET(baseURL+"/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET(baseURL+"/v2/stateproofs/:round", wrapper.GetStateProof, m...)
	router.GET(baseURL+"/v2/status", wrapper.GetStatus, m...)
	router.GET(baseURL+"/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST(baseURL+"/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST(baseURL+"/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST(baseURL+"/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.GET(baseURL+"/v2/transactions/params", wrapper.TransactionParams, m...)
	router.POST(baseURL+"/v2/transactions/simulate", wrapper.SimulateTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
