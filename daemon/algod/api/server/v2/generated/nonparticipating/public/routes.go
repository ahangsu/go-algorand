// Package public provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/algorand/oapi-codegen DO NOT EDIT.
package public

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/http"
	"net/url"
	"path"
	"strings"

	. "github.com/algorand/go-algorand/daemon/algod/api/server/v2/generated/model"
	"github.com/algorand/oapi-codegen/pkg/runtime"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/labstack/echo/v4"
)

// ServerInterface represents all server handlers.
type ServerInterface interface {
	// Get account information.
	// (GET /v2/accounts/{address})
	AccountInformation(ctx echo.Context, address string, params AccountInformationParams) error
	// Get account information about a given app.
	// (GET /v2/accounts/{address}/applications/{application-id})
	AccountApplicationInformation(ctx echo.Context, address string, applicationId uint64, params AccountApplicationInformationParams) error
	// Get account information about a given asset.
	// (GET /v2/accounts/{address}/assets/{asset-id})
	AccountAssetInformation(ctx echo.Context, address string, assetId uint64, params AccountAssetInformationParams) error
	// Get application information.
	// (GET /v2/applications/{application-id})
	GetApplicationByID(ctx echo.Context, applicationId uint64) error
	// Get box information for a given application.
	// (GET /v2/applications/{application-id}/box)
	GetApplicationBoxByName(ctx echo.Context, applicationId uint64, params GetApplicationBoxByNameParams) error
	// Get all box names for a given application.
	// (GET /v2/applications/{application-id}/boxes)
	GetApplicationBoxes(ctx echo.Context, applicationId uint64, params GetApplicationBoxesParams) error
	// Get asset information.
	// (GET /v2/assets/{asset-id})
	GetAssetByID(ctx echo.Context, assetId uint64) error
	// Get the block for the given round.
	// (GET /v2/blocks/{round})
	GetBlock(ctx echo.Context, round uint64, params GetBlockParams) error
	// Get the block hash for the block on the given round.
	// (GET /v2/blocks/{round}/hash)
	GetBlockHash(ctx echo.Context, round uint64) error
	// Gets a proof for a given light block header inside a state proof commitment
	// (GET /v2/blocks/{round}/lightheader/proof)
	GetLightBlockHeaderProof(ctx echo.Context, round uint64) error
	// Get a proof for a transaction in a block.
	// (GET /v2/blocks/{round}/transactions/{txid}/proof)
	GetTransactionProof(ctx echo.Context, round uint64, txid string, params GetTransactionProofParams) error
	// Get a LedgerStateDelta object for a given transaction group
	// (GET /v2/deltas/txn/group/{id})
	GetLedgerStateDeltaForTransactionGroup(ctx echo.Context, id string, params GetLedgerStateDeltaForTransactionGroupParams) error
	// Get a LedgerStateDelta object for a given round
	// (GET /v2/deltas/{round})
	GetLedgerStateDelta(ctx echo.Context, round uint64, params GetLedgerStateDeltaParams) error
	// Get LedgerStateDelta objects for all transaction groups in a given round
	// (GET /v2/deltas/{round}/txn/group)
	GetTransactionGroupLedgerStateDeltasForRound(ctx echo.Context, round uint64, params GetTransactionGroupLedgerStateDeltasForRoundParams) error
	// Returns the timestamp offset. Timestamp offsets can only be set in dev mode.
	// (GET /v2/devmode/blocks/offset)
	GetBlockTimeStampOffset(ctx echo.Context) error
	// Given a timestamp offset in seconds, adds the offset to every subsequent block header's timestamp.
	// (POST /v2/devmode/blocks/offset/{offset})
	SetBlockTimeStampOffset(ctx echo.Context, offset uint64) error
	// Get the current supply reported by the ledger.
	// (GET /v2/ledger/supply)
	GetSupply(ctx echo.Context) error
	// Get a state proof that covers a given round
	// (GET /v2/stateproofs/{round})
	GetStateProof(ctx echo.Context, round uint64) error
	// Gets the current node status.
	// (GET /v2/status)
	GetStatus(ctx echo.Context) error
	// Gets the node status after waiting for a round after the given round.
	// (GET /v2/status/wait-for-block-after/{round})
	WaitForBlock(ctx echo.Context, round uint64) error
	// Compile TEAL source code to binary, produce its hash
	// (POST /v2/teal/compile)
	TealCompile(ctx echo.Context, params TealCompileParams) error
	// Disassemble program bytes into the TEAL source code.
	// (POST /v2/teal/disassemble)
	TealDisassemble(ctx echo.Context) error
	// Provide debugging information for a transaction (or group).
	// (POST /v2/teal/dryrun)
	TealDryrun(ctx echo.Context) error
	// Get parameters for constructing a new transaction
	// (GET /v2/transactions/params)
	TransactionParams(ctx echo.Context) error
	// Simulates a raw transaction or transaction group as it would be evaluated on the network. The simulation will use blockchain state from the latest committed round.
	// (POST /v2/transactions/simulate)
	SimulateTransaction(ctx echo.Context, params SimulateTransactionParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
	Handler ServerInterface
}

// AccountInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// ------------- Optional query parameter "exclude" -------------

	err = runtime.BindQueryParameter("form", true, false, "exclude", ctx.QueryParams(), &params.Exclude)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter exclude: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountInformation(ctx, address, params)
	return err
}

// AccountApplicationInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountApplicationInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountApplicationInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountApplicationInformation(ctx, address, applicationId, params)
	return err
}

// AccountAssetInformation converts echo context to params.
func (w *ServerInterfaceWrapper) AccountAssetInformation(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "address" -------------
	var address string

	err = runtime.BindStyledParameterWithLocation("simple", false, "address", runtime.ParamLocationPath, ctx.Param("address"), &address)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter address: %s", err))
	}

	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params AccountAssetInformationParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.AccountAssetInformation(ctx, address, assetId, params)
	return err
}

// GetApplicationByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationByID(ctx, applicationId)
	return err
}

// GetApplicationBoxByName converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxByName(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxByNameParams
	// ------------- Required query parameter "name" -------------

	err = runtime.BindQueryParameter("form", true, true, "name", ctx.QueryParams(), &params.Name)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter name: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxByName(ctx, applicationId, params)
	return err
}

// GetApplicationBoxes converts echo context to params.
func (w *ServerInterfaceWrapper) GetApplicationBoxes(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "application-id" -------------
	var applicationId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "application-id", runtime.ParamLocationPath, ctx.Param("application-id"), &applicationId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter application-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetApplicationBoxesParams
	// ------------- Optional query parameter "max" -------------

	err = runtime.BindQueryParameter("form", true, false, "max", ctx.QueryParams(), &params.Max)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter max: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetApplicationBoxes(ctx, applicationId, params)
	return err
}

// GetAssetByID converts echo context to params.
func (w *ServerInterfaceWrapper) GetAssetByID(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "asset-id" -------------
	var assetId uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "asset-id", runtime.ParamLocationPath, ctx.Param("asset-id"), &assetId)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter asset-id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetAssetByID(ctx, assetId)
	return err
}

// GetBlock converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetBlockParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlock(ctx, round, params)
	return err
}

// GetBlockHash converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockHash(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockHash(ctx, round)
	return err
}

// GetLightBlockHeaderProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetLightBlockHeaderProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLightBlockHeaderProof(ctx, round)
	return err
}

// GetTransactionProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	// ------------- Path parameter "txid" -------------
	var txid string

	err = runtime.BindStyledParameterWithLocation("simple", false, "txid", runtime.ParamLocationPath, ctx.Param("txid"), &txid)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter txid: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionProofParams
	// ------------- Optional query parameter "hashtype" -------------

	err = runtime.BindQueryParameter("form", true, false, "hashtype", ctx.QueryParams(), &params.Hashtype)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter hashtype: %s", err))
	}

	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTransactionProof(ctx, round, txid, params)
	return err
}

// GetLedgerStateDeltaForTransactionGroup converts echo context to params.
func (w *ServerInterfaceWrapper) GetLedgerStateDeltaForTransactionGroup(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "id" -------------
	var id string

	err = runtime.BindStyledParameterWithLocation("simple", false, "id", runtime.ParamLocationPath, ctx.Param("id"), &id)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter id: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLedgerStateDeltaForTransactionGroupParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLedgerStateDeltaForTransactionGroup(ctx, id, params)
	return err
}

// GetLedgerStateDelta converts echo context to params.
func (w *ServerInterfaceWrapper) GetLedgerStateDelta(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetLedgerStateDeltaParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetLedgerStateDelta(ctx, round, params)
	return err
}

// GetTransactionGroupLedgerStateDeltasForRound converts echo context to params.
func (w *ServerInterfaceWrapper) GetTransactionGroupLedgerStateDeltasForRound(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params GetTransactionGroupLedgerStateDeltasForRoundParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetTransactionGroupLedgerStateDeltasForRound(ctx, round, params)
	return err
}

// GetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) GetBlockTimeStampOffset(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetBlockTimeStampOffset(ctx)
	return err
}

// SetBlockTimeStampOffset converts echo context to params.
func (w *ServerInterfaceWrapper) SetBlockTimeStampOffset(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "offset" -------------
	var offset uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "offset", runtime.ParamLocationPath, ctx.Param("offset"), &offset)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter offset: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SetBlockTimeStampOffset(ctx, offset)
	return err
}

// GetSupply converts echo context to params.
func (w *ServerInterfaceWrapper) GetSupply(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetSupply(ctx)
	return err
}

// GetStateProof converts echo context to params.
func (w *ServerInterfaceWrapper) GetStateProof(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStateProof(ctx, round)
	return err
}

// GetStatus converts echo context to params.
func (w *ServerInterfaceWrapper) GetStatus(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.GetStatus(ctx)
	return err
}

// WaitForBlock converts echo context to params.
func (w *ServerInterfaceWrapper) WaitForBlock(ctx echo.Context) error {
	var err error
	// ------------- Path parameter "round" -------------
	var round uint64

	err = runtime.BindStyledParameterWithLocation("simple", false, "round", runtime.ParamLocationPath, ctx.Param("round"), &round)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter round: %s", err))
	}

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.WaitForBlock(ctx, round)
	return err
}

// TealCompile converts echo context to params.
func (w *ServerInterfaceWrapper) TealCompile(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params TealCompileParams
	// ------------- Optional query parameter "sourcemap" -------------

	err = runtime.BindQueryParameter("form", true, false, "sourcemap", ctx.QueryParams(), &params.Sourcemap)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter sourcemap: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealCompile(ctx, params)
	return err
}

// TealDisassemble converts echo context to params.
func (w *ServerInterfaceWrapper) TealDisassemble(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDisassemble(ctx)
	return err
}

// TealDryrun converts echo context to params.
func (w *ServerInterfaceWrapper) TealDryrun(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TealDryrun(ctx)
	return err
}

// TransactionParams converts echo context to params.
func (w *ServerInterfaceWrapper) TransactionParams(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.TransactionParams(ctx)
	return err
}

// SimulateTransaction converts echo context to params.
func (w *ServerInterfaceWrapper) SimulateTransaction(ctx echo.Context) error {
	var err error

	ctx.Set(Api_keyScopes, []string{""})

	// Parameter object where we will unmarshal all parameters from the context
	var params SimulateTransactionParams
	// ------------- Optional query parameter "format" -------------

	err = runtime.BindQueryParameter("form", true, false, "format", ctx.QueryParams(), &params.Format)
	if err != nil {
		return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter format: %s", err))
	}

	// Invoke the callback with all the unmarshalled arguments
	err = w.Handler.SimulateTransaction(ctx, params)
	return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
	CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
	TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface, m ...echo.MiddlewareFunc) {
	RegisterHandlersWithBaseURL(router, si, "", m...)
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string, m ...echo.MiddlewareFunc) {

	wrapper := ServerInterfaceWrapper{
		Handler: si,
	}

	router.GET(baseURL+"/v2/accounts/:address", wrapper.AccountInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/applications/:application-id", wrapper.AccountApplicationInformation, m...)
	router.GET(baseURL+"/v2/accounts/:address/assets/:asset-id", wrapper.AccountAssetInformation, m...)
	router.GET(baseURL+"/v2/applications/:application-id", wrapper.GetApplicationByID, m...)
	router.GET(baseURL+"/v2/applications/:application-id/box", wrapper.GetApplicationBoxByName, m...)
	router.GET(baseURL+"/v2/applications/:application-id/boxes", wrapper.GetApplicationBoxes, m...)
	router.GET(baseURL+"/v2/assets/:asset-id", wrapper.GetAssetByID, m...)
	router.GET(baseURL+"/v2/blocks/:round", wrapper.GetBlock, m...)
	router.GET(baseURL+"/v2/blocks/:round/hash", wrapper.GetBlockHash, m...)
	router.GET(baseURL+"/v2/blocks/:round/lightheader/proof", wrapper.GetLightBlockHeaderProof, m...)
	router.GET(baseURL+"/v2/blocks/:round/transactions/:txid/proof", wrapper.GetTransactionProof, m...)
	router.GET(baseURL+"/v2/deltas/txn/group/:id", wrapper.GetLedgerStateDeltaForTransactionGroup, m...)
	router.GET(baseURL+"/v2/deltas/:round", wrapper.GetLedgerStateDelta, m...)
	router.GET(baseURL+"/v2/deltas/:round/txn/group", wrapper.GetTransactionGroupLedgerStateDeltasForRound, m...)
	router.GET(baseURL+"/v2/devmode/blocks/offset", wrapper.GetBlockTimeStampOffset, m...)
	router.POST(baseURL+"/v2/devmode/blocks/offset/:offset", wrapper.SetBlockTimeStampOffset, m...)
	router.GET(baseURL+"/v2/ledger/supply", wrapper.GetSupply, m...)
	router.GET(baseURL+"/v2/stateproofs/:round", wrapper.GetStateProof, m...)
	router.GET(baseURL+"/v2/status", wrapper.GetStatus, m...)
	router.GET(baseURL+"/v2/status/wait-for-block-after/:round", wrapper.WaitForBlock, m...)
	router.POST(baseURL+"/v2/teal/compile", wrapper.TealCompile, m...)
	router.POST(baseURL+"/v2/teal/disassemble", wrapper.TealDisassemble, m...)
	router.POST(baseURL+"/v2/teal/dryrun", wrapper.TealDryrun, m...)
	router.GET(baseURL+"/v2/transactions/params", wrapper.TransactionParams, m...)
	router.POST(baseURL+"/v2/transactions/simulate", wrapper.SimulateTransaction, m...)

}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %s", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %s", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	var res = make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	var resolvePath = PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		var pathToFile = url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
